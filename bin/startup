#!/usr/bin/env node

const {spawn, exec} = require('child_process')
const fs = require('fs')
const path = require('path')
const {parseCert} = require('x509')
const chalk = require('chalk')
const registerCert = require('../lib/register-cert')
const {DOMAINS, EMAIL} = process.env
const AUTO = process.env.AUTO || true

if (!DOMAINS || !DOMAINS.length) {
  throw new Error('No domains given.')
}
if (!EMAIL) {
  throw new Error('No email given.')
}

const domains = DOMAINS.split(',').map(v => v.trim())

registerOrRenewCerts(domains, EMAIL).then(() => {
  if (AUTO) {
    keepCertsValid()
  }
})

function registerOrRenewCerts (domains, email) {
  const cert = readCert(domains)
  if (!cert) {
    return registerCert(domains, email)
  } else {
    if (certNeedsToBeRenewed(cert)) {
      return renewCert(domains, email)
    }
  }
}

// iterate through /etc/letsencrypt/live fullchain.pem(s), using x509 to collect names
// If any names are in domains that aren't in live names, get a new cert
//otherwise, check the date of the current cert, renew if needed, set job to renew in 2 months, everyday until successful

const getCertNames = cert => cert.altNames

const certs = getCerts()
const certsNames = certs.map(getCertNames)

const existingCert = certsNames.find(certNames => {
  return String(certNames) === String(domains)
})

if (!existingCert) {
  registerCert({domains, email: EMAIL, staging: true}, (err, result) => {
    if (err) {
      console.log(err)
      process.exit(1)
    }
    console.log(result)
    server.close()
  })
} else {
  console.log(certsNames)
}
